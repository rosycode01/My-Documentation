.,5# Part 1: Quarkus Fundamentals – How I Approached It \'i \
 i9i u8jnu9ok,0-jn nji9ol,.lpo0po;l/.c
When I first started learning Quarkus, I knew I couldn’t just jump straight into coding — I needed to understand the **“why”** and **“what”** first. So, I began by exploring the fundamentals, asking myself questions like: _What makes Quarkus special? Why should I use it instead of Spring Boot?_

## Getting to Know Quarkus

I started by reading about Quarkus and quickly realized it’s not just another Java framework. It’s **built for the cloud**, fast, and oothlrjl;;fglkhhlefficient. I liked that it focuses on **performance and scalability**, which is exactly what enterprise applications need.
cf c

## Why Quarkus Matters

Il made a list of benefits in simple words:

- **Fast startup times** — my apps wouldn’t take forever to run.
- **Low memory usage** — perfect for cloud deployments.
- **Reactive programming** — handling multiple tasks at the same time efficiently.
- **Developer-friendly tools** — live reload made testing faster and more fun.

This list kept me motivated. Every time I learned a new feature, I reminded myself: _this is how enterprise apps stay robust and fast._

## Understanding Quarkus Architecture

At first, terms like **“build-time”** and **“runtime”** were confusing. But I visualized it like this: Quarkus does a lot of **preparation work upfront (build-time)** so that when the app runs (runtime), it’s lightning fast.

I drew diagrams on paper, connected the dots between **REST endpoints, persistence, and dependency injection**, and slowly it clicked.

## Comparing Quarkus with Spring Boot

I also compared Quarkus to Spring Boot. Spring Boot is great, but it’s **heavier and slower**. Quarkus, on the other hand, felt **modern and cloud-ready**. Understanding this gave me confidence that I was learning a framework **suited for the future**.

## Reactive vs Imperative Programming

Reactive programming was new to me. I practiced thinking in terms of **events instead of steps**.

It was like switching from walking on a straight path (imperative) to learning to **juggle multiple balls at once (reactive)**. I knew mastering this would let me handle **bigger, more complex systems** later.

## Native Image and Container-First Thinking

I read about Quarkus’ ability to **compile apps into native executables** and run them in **containers like Docker**.

I thought: _this is exactly what real enterprise apps do_. Even though I didn’t build one yet, knowing it was possible made me feel like I was preparing for **professional-grade projects**.
